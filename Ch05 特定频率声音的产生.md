<font size=3>**文档目录**</font>

[TOC]

# 第五节 特定频率声音的产生

> Update 2019/01/23 21:30

> Date: 2019/01/20 - 2019/01/22

> Editor: NEU - Amy Li

> Contact: hsrlhl@outlook.com



## 1 &nbsp;概要

上一节，我们着眼局部，走近了和 MainActivity 类联系最紧密的 SinVoicePlayer 类，深入理解了如何将“信息转化成一个个单频率的音频进行输出”，同时了解了 Java 相关的多线程知识。

在本节，我们将要了解本项目最核心、最基本也是最难于理解的部分——“移动设备如何产生特定频率的声音”。我将带领大家明确声音频率这个概念，分析掌握几个声音的产生过程中必须用到的重要知识和概念，然后通过简明的代码引领大家逐渐理解特定频率声音产生的原理。至此，我们将攻克本项目的一大重点和难点。



## 2 &nbsp;声音的频率

### 2.1 声音与振动

从小我们就学过**“振动不一定发声，但发声的一定在振动”**。

> 举个简单的例子，比如说敲鼓，鼓面的振动引起鼓面周围空气的不断起伏，形成了空气的振动并通过**机械波**在空气介质中传播，这种空气的的波动即为“声波”，传到了你的耳朵，就会引起耳朵鼓膜的振动，然后你就能听到敲鼓的声音。

由声源产生的振动不断地使周围的空气形成波动，这种波动以340m/s的速度在空气中扩散，这和向平静的水面投入一块石头形成的水纹是一样的原理。声音可以通过固体、液体、气体等媒介进行传播，所以如果在真空中，当然你就听不到声音了，因为没有空气这个传播介质嘛。

> 注：声波是机械波，不是电磁波

因此，倘若我们想要发出声音，就必须要让发声体产生振动。比如，我们要说话，声带就要振动；我们的手机要播放音乐，手机的喇叭就要振动。

### 2.2 振动与频率

既然发出声音必须要有振动，那么振动就会有快和慢之分，于是，我们把 1s 内物体振动的次数叫做声音的频率。

> 频率低的声音低沉有力，能传播很远的距离，比如说大象之间通信就是利用频率很低的次声波。而蝙蝠，我们都知道是通过超声波进行探路的，超声波就是振动频率比较高的声音。

频率太高或者太低，人的耳朵都听不到，人耳的识别范围是20Hz ~ 20000Hz。这里引出了一个单位，叫做赫兹(Hz)，它是指一秒钟的振动的次数。



## 3 &nbsp;产生特定频率的声音

既然不同的声音有不同的频率，那么我们可以编写一个编码本，假设1000Hz的声音对应1，1100Hz的声音对应2，以此类推，我们就可以用不同的频率对应不同的数字组合。在接收到声波之后，再根据不同的频率还原成对应的数据即可。

倘若我们想要发出某一频率的声音，即产生某一特定频率声音的波形，就需要构造特定频率的波形函数（正弦函数）。你一定会问，这么做是为什么呢？比如说，手机喇叭发出声音是因为手机喇叭的振动，而喇叭的振动是因为电流带动鼓纸，因此，喇叭发出声音是因为喇叭在振动的时候，实际上是不同的电流带动鼓纸，进行不同频率的振动，然后才发出声音的。现如今，如果我们想要发出某一频率的声音，我们就要设计对应的正弦函数，来提供一定规律的“电流”。

### 3.1 名词解释

在设计特定频率声音的正弦函数之前，我们首先需要了解几个基本的概念。

- **采样位数**

[采样位数](https://baike.baidu.com/item/%E9%9F%B3%E9%A2%91%E9%87%87%E6%A0%B7/446474?fr=aladdin)，即采样值或取样值，是采集和播放声音文件时使用的数字声音信号的二进制位数。

采样位数可以理解为声卡处理声音的解析度。这个数值越大，解析度就越高，录制和回放的声音就越真实。我们首先要知道：电脑中的声音文件是用数字0和1来表示的。所以在电脑上录音的本质就是把模拟声音信号转换成数字信号。反之，在播放时则是把数字信号还原成模拟声音信号输出。

根据采样位数的定义，声卡的位是指声卡在采集和播放声音文件时所使用数字声音信号的二进制位数。声卡的位客观地反映了数字声音信号对输入声音信号描述的准确程度。8位代表2的8次方，即256，16位则代表2的16次方，即64K。比较一下，一段相同的音乐信息，16位声卡能把它分为64K个精度单位进行处理，而8位声卡只能处理256个精度单位，造成了较大的信号损失，最终的采样效果自然是无法相提并论的。

- **采样率**

[采样频率](https://baike.baidu.com/item/%E9%87%87%E6%A0%B7%E9%A2%91%E7%8E%87/1494233?fr=aladdin)，又叫采样率，百度上的解释是每秒从连续信号中提取并组成离散信号的采样个数，用赫兹（Hz）来表示。通俗来讲，就是指每秒钟采集声音样本的次数，是描述声音文件的音质、音调，衡量声卡、声音文件的质量标准。

采样频率的倒数就是采样周期或采样时间，指两次采样之间的时间间隔。

平常我们的讲话，产生的是模拟信号，就是时间连续的信号，如果我们想把语音录制下来怎么办呢？我们是做不到完完全全的都录制下来的，我们只能每隔一段时间采集一次数据，将模拟信号转化成数字信号，因此，单位时间内采集的声音样本数据多少，也就是采样点的多少就影响到语音的质量了。如果采样频率高，采样的间隔时间短，则采样点数量就多，那么声音质量就高，对声音波形的表示就更为精确，听起来就和原声的差别小；相对的，采样频率低，采样的间隔时间长，则采样点少，声音质量就差，听起来就和原声不一样。这就是采样率的作用。

- **采样定理**

上面讲述说，采样频率高，那么声音的质量就好高，那是不是采样率越高越好呢？当然不是。

随着采样率的提高，虽然声音的质量提高了，但是采样的难度也相应增加了。同时，采样出来的数据需要存储，采样率越高，产生的数据文件就越大，因此质量高的音乐比一般的音乐的体积要大。所以，选择一个合适的采样率尤为重要。

在信号处理领域，有一个定理叫“采样定理”。[采样定理（sampling theory）](https://baike.baidu.com/item/%E9%87%87%E6%A0%B7%E5%AE%9A%E7%90%86)，即奈奎斯特定理/香农定理，是模拟信号和数字信号之间的基本桥梁。它为采样率建立了一个足够的条件，该采样率允许离散采样序列从有限带宽的连续时间信号中捕获所有信息。

采样定理的内容是：在进行模拟/数字信号的转换过程中，当采样频率 $f_{smax}$ 大于信号中最高频率 $f_{max}$ 的2倍时（即 $f_{smax} > 2 · f_{max}$ ），采样之后的数字信号就完整地保留了原始信号中的信息，一般实际应用中保证采样频率为信号最高频率的2.56～4倍。

> 【注】人耳可听范围为 20Hz ~ 20kHz，我们常见的音频文件采样率多为**44.1kHz**，也就是一分钟采样44100次，这意味着什么呢？

> 20Hz 的声音信号每次振动被采样了 ${44.1k \over 20} = 2205$ 次，而 20kHz 的声音信号每次振动只被采样了 ${44.1k \over 20k} = 2.205$ 次。可见，在相同的采样率下，记录低频的信息远比高频的要详细得多。

- **采样点数**

采样率和采样点数不同，如果说采样率决定了采样的精度，那么采样点数则决定了每次传到计算机内的数据量。

比如采样点数设为1000，计算机内会开辟初始大小1000的buffer（buffer大小可以自己改）, 每采集到1000个采样点之后就往计算机内传一次。程序每次从buffer读1000个采样点进行处理。所以如果你每次处理需要更多数据，可以增加采样点数。

因此，如果采样频率是1000Hz，则代表每秒钟采集1000个采样点，此时若采样点数为100，则每秒钟向计算机传送10次。

### 3.2 代码实现与解析

了解了几个基本的概念之后，我们继续来关注如何产生特定频率的声音。在了解这一部分的代码时，可以对照着项目的源代码和下面的代码一同来理解。

项目源代码中，产生特定频率声音的正弦波生成类是**SinGenerator**类，在这个类中主要的函数是 gen() 函数，对传入的特定频率的声音进行编码，生成正弦波。

下面的代码只给出类的 gen() 方法，为了更好地着眼于局部而非整个系统的流程，我删除并修改了一些与整个系统流程相关的，而对声音的产生无关紧要的代码。同时，源代码中的传入参数 genRate 和 duration 以及其他的类定义的成员变量，在下面的代码中均用可追踪到的具体数值替代。

我们以采样率为 44100Hz，16位采样，该函数的传入参数分别为 17011Hz 和 100ms（代表某字符的频率为17011Hz，且该字符的声音持续时间为100ms）为例，得到如下代码：

```java
public void gen()
{
    int mGenRate = 17011;//声音的频率，单位Hz
    int mDuration = 100;//该频率的声音持续时间，单位ms
    int n = 32768/2;//定值16384
    int mSampleRate = 44100;//采样率，每秒钟采样44100次
    byte mData[];//存储声音信息的数组，数组较大
    mData = new byte[4096*4];
    
    //totalCount 跟该频率的持续时间有关，下面解释
    int totalCount = (mDuration * mSampleRate) / 1000;
    int mFilledSize = 0;
    int mBufferSize = 4096*4;

    double per = (mGenRate / (double) mSampleRate) * 2 * Math.PI;//类似于步进
    double d = 0;
    for (int i = 0; i < totalCount; ++i) {
    	//out 为16bit量化存储声音的信息
        int out = (int) (Math.sin(d) * n) + 16384;
        System.out.println("out is "+ out);
        //如果填充数量超过了缓冲区大小，就重置mFilledSize，释放bufferData
        if (mFilledSize >= mBufferSize - 1) {
            ...
        }
        //取out的低八位，相当于out%256
        mData[mFilledSize++] = (byte) (out & 0xff);
        //取out的高八位，相当于out/256
        //整个过程是低八位放在前面，高八位放在后面，两个为一组，所有组按顺序存放在mData[]中
        mData[mFilledSize++] = (byte) ((out >> 8) & 0xff);
        //System.out.println("is "+ (byte) ((out >> 8) & 0xff));
        d += per;
    }   
}
```

关于 gen() 方法的代码，有几个值得思考的地方：

**1. int n = 32768/2;**

- **32768 的来源：**我们知道 $32768 = 2^{15}$  $65536 = 2^{16}$ ，在源代码中这个32768的数值取自 SinGenerator 类的 public static final int 类型的成员变量 BITS_16，与之对应的是 BITS_8 ，所以这个 BITS_16 就代表了16位采样，精度单位是 65536，也就是正弦波函数的正负峰值相差65536，即波峰处 32768，波谷处 -32768。因此，BITS_16 就是16位采样的正弦波波峰的取值。
- **n的取值是峰值除以2：**这里的 n，在后面的代码中参与了运算，n 的值是我们要设计的正弦函数的峰值大小，即最高点处的纵坐标，我们采用将实际峰值除以 2 的 16384，是为了识别率考虑。若直接采用 32768，发出的声音较为尖锐，识别率降低很多，因此，我们将其除以 2 作为峰值。

**2. int totalCount = (mDuration * mSampleRate) / 1000;**

这里的 totalCount 在下面的 for 循环里有用到，在 for 循环中用来控制循环次数。mDuration是持续时间，1个字符的持续时间，单位是毫秒，$1s = 1000 ms$，因此 $mDuration \over 1000$ 代表1个字符持续的秒数。mSampleRate 是采样率，1s 内采样的次数，采样率乘以1个字符持续的秒数，得到的就是1个字符被采样的次数。结果是 4410，所以 for 循环执行的次数也是 4410 次。

**3. int out = (int) (Math.sin(d) * n) + 16384;**

这一行代码是该方法中最重要的代码，也就是生成正弦波函数的代码。

- **out：** 要产生的声音信息
- **sin 函数：**用来生成正弦波的，值域是 [-1, 1]，乘以 n 之后值域就变成了 [-n, +n]

- **+ 16384：**n 的取值是16384，当前值域为 [-n, +n]，加上该数值之后，值域非负，[0, 32768]

**4. 正弦函数相位 d 的改变**

我们来关注一下 sin 函数的参数 d 是如何发生变化的。

```java
double per = (mGenRate / (double) mSampleRate) * 2 * Math.PI; 
double d = 0;//初始化

//在 for 循环内部有关 d 改变的代码
int out = (int) (Math.sin(d) * n) + 128;
d += per;
```

每次 d 数值的变化均与 per 有关，每次 for 循环中 d 都要加一个固定的值 per，那么我们来看一下 per 这个值。

不难发现，$per * {mSampleRate \over mGenRate} = 2\pi$，如果令 $M = {mSampleRate \over mGenRtae}$，那么我们得到这样的结论：per 就是把一个周期的 $2\pi$ 分成 M 份之后的每 $1 \over M$ 个周期，相当于 per 是记录每次循环往前走的距离。因此，由$sin(d)$ 产生的 out 的一系列数据是一个周期性变化的数据，每 M 个数据就是一个周期。取一个周期的正弦波的波形，就会由 M 个数据点构成。假如采样一个数据点的间隔为 $p \: (\mu s)$，那么产生一个周期正弦波的波形则需要 $pM \: (\mu s)$， 那么频率就是 $1 \over pM$。因此，要产生不同频率的声音，只需改变对应的 per 值即可。倘若 per 数值比较大，那么 d 就会很快经历一个周期，产生的声音的频率就会比较高。

可是，per 这个数的数值究竟是为什么用这个公式表达的呢？

希望你能跟紧我的思路来考虑一下，采样率是指 1s 中采集声音样本 44100 次，也就是 1s 内要有 44100 个数据点，那么采集每个数据点之间的采集间隔为 ${1 \over 44100}s$。假设我们要产生的声音是 17011Hz，那么该声音波形的周期就是 ${1 \over 17011}s$，所以，要产生一个周期的 17011Hz的声音（即一个周期的声音波形）就需要由 ${1 \over 17011} / {1 \over 44100}$个数据点构成。

因此，${{2\pi} \over per} = {1 \over 17011} / {1 \over 44100}$，即 ${{2\pi} \over per} = {1 \over mGenRate} / {1 \over mSampleRate}$，即 $per = {1 \over mGenRate} / {1 \over mSampleRate} * 2\pi$，也就是代码中所见到的公式 $per = {mGenRate \over mSampleRate} * 2\pi$

**5. 16位采样得到的声音存储形式**

我们注意到 for 循环最后有几行代码：

```java
//取out的低八位，相当于out%256
mData[mFilledSize++] = (byte) (out & 0xff);
//取out的高八位，相当于out/256
//整个过程是低八位放在前面，高八位放在后面，两个为一组，所有组按顺序存放在mData[]中
mData[mFilledSize++] = (byte) ((out >> 8) & 0xff);
```

这一部分的注释很详尽，但还是要强调一点，由于我们采用的是16位采样，所以应将产生的声音信息分成高八位低八位存储起来，在发送之前声卡会读取16位数据并产生声音。

如果我们采用的是8位采样，我们只需要进行上面第一行代码（不算注释的第一行）中的语句即可，无需进行下面的代码。



### 参考内容

非常感谢CSDN博主的文章，给予了我理解 SinVoice 代码并进行本项目继续开发的清晰而丰富的思路。

在这里附上博主的文章链接：https://blog.csdn.net/zhaokaiqiang1992



# 下节要做什么？

在本节我们从“移动设备如何产生特定频率的声音”入手，先是明确了声音频率这个概念，然后分析掌握了几个声音的产生过程中必须用到的重要知识和概念，最后通过简明的代码逐渐理解了特定频率声音产生的原理。

下一节，我们将为声音的播放做准备工作，实现将特定频率的声音包含的一连串数据信息存入指定的 Buffer 中，时刻为声音的播放准备着。

  
